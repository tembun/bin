#!/bin/sh

#
# mconv -- media converter.
#

progname=$(basename $0)

usage()
{
	cat 1>&2 <<__EOF__
Usage: $progname from to
       $progname [-d output_directory] -e output_extension file ...
__EOF__
	exit 2
}

warn()
{
	echo "$progname: $@" 1>&2
}

err()
{
	echo "$progname: $@" 1>&2
	exit 1
}

report_progress()
{
	([ -n "$conv_src" ] && [ -n "$conv_tgt" ]) || return
	echo "$progname: Converting $conv_src -> $conv_tgt" 1>&2
}

siginfo_handler()
{
	report_progress
	# The wait() in do_conv() gets interrupted when signal arrives, which
	# leads to the situation when script reports that converting of a
	# currently converted file is done and jumps to the next one, meanwhile
	# the conversion has not actually finished (it's still continuing in
	# the background).  To prevent that, 'restore' that wait() here so to
	# not report about successfull conversion before it actually happens.
	#
	wait $!
	[ $? -eq 0 ] && echo "$src -> $tgt"
}

trap siginfo_handler INFO

get_ext()
{
	local file=$(basename "$1")
	local _ext=$(echo "$file" |grep -Eo '\..+$' |sed 's/^\.//')
	
	setvar "$2" "$_ext"
}

get_target_path()
{
	local src="$1"
	local target target_base
	
	get_ext "$src" ext
	[ -n "$ext" ] || warn "$src extension not found; skip"
	target_base=$(basename "$src" |sed "s~$ext$~$target_ext~")
	[ ! -d "$target_dir" ] && target_dir=$(dirname "$src")
	mkdir -p "$ta.rget_dir" || err "Can't create directory $target_dir"
	target="$target_dir/$target_base"
	echo "$target"
}

check_ffmpeg()
{
	which ffmpeg 2>&1 >/dev/null || err "ffmpeg(1) is required"
}

set_ffmpeg_opts()
{
	local ext_src="$1"
	local ext_tgt="$2"
	
	if ([ "$ext_src" = "mkv" ] && [ "$ext_tgt" = "mp4" ]) || \
	    ([ "$ext_src" = "mp4" ] && [ "$ext_tgt" = "mkv" ]); then
		ffmpeg_opts="-c copy -map 0"
	fi
}

preconv_check()
{
	local src="$1"
	local tgt="$2"
	
	[ -f "$src" ] || err "$src doesn't exist"
	if [ -f "$tgt" ]; then
		existing="$tgt
$existing"
	else
		safe_srcs="$src
$safe_srcs"
	fi
}

do_conv()
{
	local src="$1"
	local tgt="$2"
	conv_src="$src"
	conv_tgt="$tgt"
	
	get_ext "$src" src_ext
	get_ext "$tgt" tgt_ext
	set_ffmpeg_opts "$src_ext" "$tgt_ext"
	# Put this job in the background to be able to receive SIGINFO
	# (otherwise it would be delivered to ffmpeg(1) and not to us).
	#
	ffmpeg -loglevel 8 -y -i "$src" $ffmpeg_opts "$tgt" &
	# See notes in siginfo_handler().
	wait $!
	[ $? -eq 0 ] && echo "$src -> $tgt"
}

handle_args()
{
	local srcs=$(echo "$@" |sort |uniq)
	local src tgt sure
	local final_srcs
	
	if [ -z "$target_ext" ]; then
		[ $# -eq 2 ] && [ -z "$target_dir" ] || usage
		src="$1"
		tgt="$2"
		preconv_check "$src" "$tgt"
		if [ -n "$existing" ]; then
			printf "$tgt already exists. Overwrite? [y/N]: " 1>&2
			read sure
			[ "$sure" != "y" ] && [ "$sure" != "Y" ] && exit 0
		fi
		do_conv "$src" "$tgt"
	else
		for src in $srcs; do
			tgt=$(get_target_path "$src")
			preconv_check "$src" "$tgt"
		done
		final_srcs="$srcs"
		if [ -n "$existing" ]; then
			printf "Some files already exist:\n$existing" 1>&2
			printf "Overwrite them? [y/N/q]: " 1>&2
			read sure
			[ "$sure" = "q" ] && exit 0
			[ "$sure" != "y" ] && [ "$sure" != "Y" ] && \
			    final_srcs="$safe_srcs"
		fi
		for src in $final_srcs; do
			tgt=$(get_target_path "$src")
			do_conv "$src" "$tgt"
		done
	fi
}

check_ffmpeg
while getopts "e:d:" o; do
	case $o in
	e) target_ext="$OPTARG";;
	d) target_dir="$OPTARG";;
	?) usage;;
	esac
done
shift $((OPTIND - 1))
handle_args $@
